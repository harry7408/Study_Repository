# 람다 함수로 프로그래밍 하기

## 다루는 내용

함수에 코드 스니펫과 동작을 전달하기 위한 람다 식과 멤버 참조 사용 방법

Kotlin에서 함수형 인터페이스 정의와 Java 함수형 인터페이스 활용법

Receiver 람다 사용법 (DSL의 Base 가 된다)

→ 람다 본문이 주변 코드와 다른 Context에서 실행되는 특별한 종류의 람다이다

⭐ 람다식은 다른 함수에 전달할 수 있는 작은 코드 조각으로 공통 코드 구조를 라이브러리 함수로 추출해서 재사용성을 높이고 표현력을 향상시킬 수 있다

→ 특히 Kotlin Standard Library에서 광범위하게 활용된다

### 람다 식과 멤버 참조

Java 8 부터 람다가 등장하였고 이는 언어 발전 과정에서 가장 오랫동안 기다려온 변화 중 하나였다 (매우 중요한 일)

- 람다 함수 소개 : 코드 블럭을 값처럼
    - 특정  동작을 전달하고 저장하는 일은 매우 빈번하게 발생한다. Java 8 이전 버전에서는 익명 내부 Class를 통해 구현하였다
        
        → 익명 내부 Class는 기능을 수행하지만 코드가 너무 장황한 단점이 있다
        
    - 함수를 값으로 취급하면서 이를 편하게 사용할 수 있게 되었고, 클래서를 선언하고 인스턴스를 메서드에 전달하는 대신 함수를 직접 전달할 수 있게 되었다 (By Lambda)
    
    💡 함수형 프로그래밍 리마인드
    
    ```
    1. 일급 함수 (First-Class Functions)
     - 함수가 값으로 취급된다
    	 (함수를 변수로 저장, 매개변수로 전달, 다른 함수에서 반환 등)
     => 람다는 함수를 일급 시민으로 편리하게 다룰 수 있게 해준다
    
    2. 불변성 (Imumutability)
     - 객체가 생성된 후 내부 상태가 변경될 수 없도록 보장하는 방식으로 설계
    
    3. 부수효과 없음 (No Side Effect)
     - 동일한 입력이 주어졌을 때 항상 동일한 결과를 반환하고
       다른 객체의 상태나 외부 세계를 수정하지 않도록 함수를 구조화
     => Pure Function
    ```
    
    > 람다 함수 활용 예시
    > 
    
    ```kotlin
    //  익명 객체를 활용한 방법 (장황하고 반복적인 코드)
    button.setOnClickListener(object: OnClickListener) {
    	override fun onClick(view: View) {
    		println("Clicked")
    	}
    }
    
    // 람다 사용 코드 (매우 간결)
    button.setOnClickListener {
    	println("Clicked")
    }
    ```
    
    두 코드는 동일한 동작을 하나 람다를 활용한 2번째 코드가 훨씬 간결하다
    

- 람다와 컬렉션
    - 람다는 Kotlin이 Collection 작업을 위한 강력한 기능들을 제공하는 편리한 표준 라이브러리를 제공할 수 있도록 해준다. (코드의 중복을 피함)
  
    
    > Collection에서 람다 활용 예시 + Member Reference
    > 
    
    ```kotlin
    // 사용자 정의 Class
    data class Person(val name: String, val age: Int)
    
    // 나이가 가장 많은 사람 찾기 (Collection 함수 활용 X)
    fun findOldestPerson(people: List<Person>) {
    	var max = 0
    	var oldest: Person? = null
    	for(person in people) {
    		if(person.age > max) {
    			max=person.age
    			oldest=person
    		}
    	}
    	println(oldest)
    }
    
    fun main() {
    	val people = listOf(Person("A",10), Person("B",12))
    	findOldestPerson(people)
    }
    ----------
    Person(name = B, age = 12)
    ----------
    
    // Collection에서 제공하는 메서드 활용 (STL)
    fun main() {
    	val people = listOf(Person("A",10), Person("B",12))
    	println(people.maxByOrNull { it.age })
    }
    ----------
    Person(name = B, age = 12)
    ----------
    
    // Member Reference
    people.maxByOrNull(Person::age)
    ```
    
    첫 번째는 흔히 PS를 할 때 최대 값을 구현하는 방식이고 두 번째는 Kotlin STL에서 제공하는 `maxByOrNull` 메서드를 활용한 방식이다
    
    → 하나의 인자를 받으며 최대 요소를 찾기 위해 어떤 값들을 비교해야하는지 지정하는 함수 ( {it.age} )로 나이로 비교하겠다는 것을 의미)
    
    → 람다가 단 하나의 인수를 받고 명시적인 이름을 지정하지 않아 `it` 키워드로 값을 참조할 수 있다
    
    마지막은 람다가 단순히 함수나 속성에 위임하기만 한다면 멤버 참조로 대체될 수 있음을 보여준다
